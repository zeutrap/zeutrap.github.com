---
layout: post
title: "傻瓜也能做的可扩展性"
description: ""
category: "architecture"
tags: ["all-time-favorites系列", "一日一架构", "架构", "译文"]
---
{% include JB/setup %}

本文翻译自 lecloud.net的[Scalability for Dummies系列文章](http://www.lecloud.net/search/scalability)。原本为独立的四篇文章，在这里译者将其整合在一起。  

不久前有人问我如何保证网站服务在大规模访问下的可扩展性？我的答案比较冗长，而且考虑到可能有其他人也对这个感兴趣，所以我在博客中将它分享出来，并且为了方便阅读，我把整个答案分成了几篇文章。我会定期地发布新的部分。  

## 复制
可扩展的网页服务器通常隐藏在一个负载均衡器后面。这个负载均衡器近似均匀地将负载(来自于用户的请求)分发到你的应用服务器群组或者集群上。举个例子来说，用户Steve对你的服务感兴趣，他的第一次请求可能被你的服务器2处理，然后第二个请求被服务器9处理，然后第三个请求被服务器2处理。  

不管Steve实际使用的是哪台服务器，他请求的结果都应当是一样的。这就引出了第一条扩展性的金牌定律：每台服务器包含完全一样的代码库，并且不能够在本地磁盘或者内存中存储任何与用户有关的数据，比如Session或者个人图片等等。  

Session应当被存储在一台可以被任何应用服务器访问的中央数据存储上。它可以是一个数据库，也可以基于性能的考虑是一个可持久化的缓存，比如Redis。值得注意的是：数据不要保存在你的应用服务器上，但是应该在或者靠近你应用服务器的数据中心。  

部署应该怎么做呢？你怎么样才能确保代码更改被推送到所有的服务器上而不是遗漏了某些台？幸运的是我们能够使用一个名叫Capistran的利器来解决这个棘手的问题。它需要付出一些学习的代价，尤其是你没用过Ruby on Rails的时候，但是，这绝对是值得的。  
通过“外包”Session和在所有服务器上使用同一份代码，你现在能够从其中的一台服务器上创建一个镜像文件(AWI称之为AMI-Amazon机器镜像)。使用这个AMI文件作为母体，基于它创建你所有的新的实例。在任何你想启动一个新的实例/克隆的时候，你需要做的仅仅是使用你最新的代码做一次初始化部署。  

## 数据库
通过上面的处理，你的服务器就能够水平扩展，同时服务上千的并发请求。但是在有些路径上你的应用会越来越慢最后崩溃。原因在于你的数据库。你用的是MySQL对吧？  

现在，你需要做的不是添加更多的机器，而是对你的服务进行大量调整，甚至需要进行比较彻底的调整。最终，你会选择两条路：  
**选择 1** 是继续使用MySQL并且与之持续战斗。雇佣一个DBA,告诉他来做主从备份（主写从读），不停地为你的主服务器增加内存、内存和内存。在几个月后，你的DBA就会碰到“切分”，“反模式化”和“SQL调优”的字样，然后开始担忧接下来几周都必须要加班了。在这条路上，你的每一个维持数据库运转的动作不管是在时间还是金钱上都会越来越昂贵。所以可能你最好还是在你的数据库很小并且容易迁移的时候就选择第二条路。  
**选择 2** 意味着从一开始就反模式化，数据库查询中不要有任何的Join操作。你可以继续使用MySQL，不过要像使用NoSQL数据库一样使用。或者你可以切换到具有更好和更易扩展性的NoSQL数据库，比如MongoDB或者CouchDB。如果你需要做Join操作，那么你需要在你的应用代码里面自己做。在这一步你做的越快，你需要修改的代码就越少。  
但是，即便你成功地切换到最新最好的NoSQL数据库，也在应用中自己来做数据集合的Join操作，过一段时间你的数据库请求依旧会越来越慢。这时候你需要使用缓存了。  

## 缓存  
现在你有了一个可扩展的数据库解决方案。你不用在担心如何存储上T的数据，看起来世界是很美好的。但是，仅仅是对你来说世界是美好的。你的用户依旧会碰到从数据库中获取一些数据时页面相应慢的问题。解决方案是引入缓存。  
这里的“缓存”我指的是像Memcached或者Redis这样的内存中的缓存。**永远不要使用基于文件的缓存**，它会让你的复制和服务器自动扩展成为噩梦。  
我们回到基于内存的缓存。缓存是一个简单的kv存储，它应当充当你的应用和存储之间的缓冲层。当你的应用想去读取数据的时候，你应当第一时间尝试去缓存中检索数据。而且仅当数据不在缓存中时才去主数据源处获取数据。为什么要这样做？因为**缓存快如闪电**。它将所有数据集都存储在内存中，请求将会被处理得特别快。举个例子来说，一个标准服务器上的Redis每秒能处理几十万次的读操作。写操作也是特别特别快，尤其是增量写。和数据库一起使用吧。  
下面有两种缓存数据的模式。一种新的，一种旧的：  
**#1 - 缓存数据库查询**  
它仍然是最常使用的缓存模式。当你查询完数据库时，将结果数据集存储到缓存中。你可以将你查询的MD5值作为缓存的键。下一次你再查询时，你首先检查缓存中是否有这个数据。这个模式有一些问题。主要的问题是过期时间。当你缓存了一个复杂查询时，删除缓存结果就变得很难。当数据中的一部分（比如一个表中的格子）发生改变时，你需要去删除所有已缓存的查询。因为它们有可能包含了这个格子。  
**#2 - 缓存对象**  
这是我强烈推荐也是我通常用的模式。简单来说，就是像你的代码中一样将数据看成是一个对象。让你的类将数据库中的一个数据集组合起来，然后将这个类的完整实例或者组合的数据集存储到缓存中。我知道这看起来听太过里路呢，但是你看看你常用的代码。举个例子来说，你有一个类叫做"Product"，它有一个属性叫做"data"。它是一个包含有产品的价格，文本，图片和顾客评价的数组。这个"data"数据来自于类中的很多方法。这些方法对数据库做了很多次难以缓存而又相互关联的查询。因此，现在这样做：当你的类完成了对数据数组的组合之后，直接将这个数据数组或者将这个类的完整实例(这样做更好)存储到缓存。这样能让你轻松摆脱那些发生改变的对象造成的困扰。而且也使得你代码的整个操作更快和更有逻辑性。  
最好是将这个过程尽可能的异步化。你想像一下有一支专门组合数据的部队为你工作。应用只需要消费最新的缓存对象，永远不用接触数据库。  
一些可以缓存的对象：  
* 用户Session（永远不要使用数据库）  
* 完整的博客文章  
* 活动流  
* 用户好友关系  
你可能已经猜到，我是缓存的爱好者。它很通俗易懂，实现也非常简单，而结果也很有效。通常来说，相对于Memcached，我更喜欢用Redis，因为我很喜欢Redis的一些额外数据库功能，比如持久化和列表、集合等内建的数据结构。使用Redis和一个聪明的键策略，你甚至可以完全不使用数据库。但是如果你仅仅只需要缓存，使用Memcached,因为它能够完美地扩展。  
尽情地缓存吧！  

## 异步
想像一下你从你最喜欢的面包店里面买面包。当你走进面包店，你点了一个面包。但是不凑巧的是现在店里面没有。反而你被告知在两个小时后回来拿你预定的面包。你不觉得这样很扯淡吗？  
为了避免这种“请等上一段时间”的状况，可以使用异步。面包店的好的解决方案也可能是你的网页服务或者网页应用的好的解决方案。  
通常来说，有两种异步的方法/范例。  
**异步方案1**  
让我们回到刚才的面包店场景。第一种异步处理的方法是“晚上烘焙面包，早上出售”。收银台和顾客都不需要等待时间。对于一个Web应用来说就是提前做好耗时的工作，利用完成的工作在很短的响应时间内提供服务。  
这个范例非常频繁地用来将动态内容转换成静态内容。比如一个网站的网页，通常是由一个较大的框架或者CMS来构建的，它是针对每一次改动都预先渲染好并存储成静态的HTML文件。通常这些计算任务会被定期执行，可能是一个被cronjob每隔一小时调用的脚本。这些生成数据的预计算能够极大地帮助网站和网页应用，为其带来极高的扩展性和性能。想像一下如果你的脚本将这些预渲染的HTML页面上传到AWS S3或者Cloudfrom或者其他的CDN网络，你的网站的可扩展性将会多大。你的网站将会是极低的相应时间，每小时能服务百万级的访问者。  
**异步方案2**  
回到面包店。不幸的是有时会有一些顾客有特殊的要求需要自定义产品。比如，一个有着“Happy Birthday, Steve”字样的生日蛋糕。面包店不能够预测将来可能会有的顾客特殊需求，所以会当顾客来的时候接受顾客的任务并告诉他明天再过来去专门为其定制的蛋糕。对于一个网页服务来说，这就意味着异步处理任务。  
这是一个典型的工作流：  
一个用户来到你的网站开始一个计算非常复杂的任务，这个任务需要几分钟才能完成。所以你的网站前端会将这个任务发送给任务队列，并马上告诉用户：你的任务已经在处理中了，请继续浏览网页。一群worker会不停地检查任务队列来寻找新的任务。如果一个worker发现了新任务，那么它会开始做这个任务。几分钟之后，它会发送一个信号告知这个任务已经完成。这样的话，一直在检查“任务已经完成”信号的前端会看到这个任务已经完成，并会通知用户。  
我知道，这个例子非常抽象，而且我甚至忽略了一些进一步的概念和命名约定（比如生产者和消费者）。  
如果你想进一步了解细节和实际的技术设计，我建议你可以读读RabbitMQ官方网站的[前三个教程](http://www.rabbitmq.com/tutorials/tutorial-six-python.html)。RabbitMQ是一个帮助实现异步处理的系统。你也可以使用[ActiveMQ](http://activemq.apache.org/)或者简单的[Redis](http://redis.io/)列表。但是大部分的这些系统归结为一个队列。一个任务将被推进这个队列，并被一个处理的worker拉走。  
异步看起来比较复杂，但是它绝对值得花时间来学习和实现。后端将会具有近乎无限的可扩展性，而前端会改善用户体验。  
如果你的操作是高时间消耗的，请尝试将它异步化。  

